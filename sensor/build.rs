//! Build script for waterkit-sensor.
//!
//! Handles platform-specific code generation:
//! - Apple: Swift bridge generation
//! - Android: Kotlin â†’ DEX compilation

use std::{env, path::PathBuf, process::Command};

fn main() {
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap();

    // Apple platforms: generate Swift bridge
    if target_os == "ios" || target_os == "macos" {
        build_apple();
        if target_os == "macos" {
            println!("cargo:rustc-link-lib=framework=IOKit");
        }
    }

    // Android: compile Kotlin to DEX
    if target_os == "android" {
        build_android();
    }
}

fn build_apple() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    let bridges = vec!["src/sys/apple/mod.rs"];
    for bridge in &bridges {
        println!("cargo:rerun-if-changed={bridge}");
    }

    #[cfg(any(target_os = "ios", target_os = "macos"))]
    {
        swift_bridge_build::parse_bridges(bridges)
            .write_all_concatenated(out_dir, env!("CARGO_PKG_NAME"));
    }

    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
    {
        let _ = (out_dir, bridges);
    }
}

fn build_android() {
    const KOTLIN_FILE_RELATIVE_PATH: &str = "src/sys/android/SensorHelper.kt";

    println!("cargo:rerun-if-changed={KOTLIN_FILE_RELATIVE_PATH}");

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let kotlin_file =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()).join(KOTLIN_FILE_RELATIVE_PATH);

    let android_jar_path = android_build::android_jar(None).expect("Failed to find android.jar");

    // Compile .kt -> .class using kotlinc
    let classes_dir = out_dir.join("classes");
    std::fs::create_dir_all(&classes_dir).expect("Failed to create classes directory");

    let kotlinc_output = Command::new("kotlinc")
        .arg("-classpath")
        .arg(&android_jar_path)
        .arg("-d")
        .arg(&classes_dir)
        .arg(&kotlin_file)
        .output()
        .expect("Failed to run kotlinc - is Kotlin compiler installed?");

    if !kotlinc_output.status.success() {
        eprintln!("kotlinc stderr: {}", String::from_utf8_lossy(&kotlinc_output.stderr));
        panic!("kotlinc compilation failed");
    }

    // Find all .class files recursively
    let mut class_files = Vec::new();
    find_class_files(&classes_dir, &mut class_files);

    assert!(!class_files.is_empty(), "No .class files generated by kotlinc");

    let d8_jar_path = android_build::android_d8_jar(None).expect("Failed to find d8.jar");

    // Convert .class -> .dex using D8
    let mut java_run = android_build::JavaRun::new();
    java_run
        .class_path(&d8_jar_path)
        .main_class("com.android.tools.r8.D8")
        .arg("--classpath")
        .arg(&android_jar_path)
        .arg("--output")
        .arg(&out_dir);

    for class_file in &class_files {
        java_run.arg(class_file);
    }

    let d8_result = java_run
        .run()
        .expect("failed to acquire exit status for java d8.jar invocation");

    assert!(d8_result.success(), "D8 dexing failed");
}

fn find_class_files(dir: &PathBuf, results: &mut Vec<PathBuf>) {
    if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                find_class_files(&path, results);
            } else if path.extension().is_some_and(|e| e == "class") {
                results.push(path);
            }
        }
    }
}
